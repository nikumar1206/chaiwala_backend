// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addComment = `-- name: AddComment :one
INSERT INTO recipe_comments (
  recipe_id, user_id, comment
) VALUES (
  $1, $2, $3
)
RETURNING id, recipe_id, user_id, comment, created_at
`

type AddCommentParams struct {
	RecipeID pgtype.Int4
	UserID   pgtype.Int4
	Comment  string
}

func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) (RecipeComment, error) {
	row := q.db.QueryRow(ctx, addComment, arg.RecipeID, arg.UserID, arg.Comment)
	var i RecipeComment
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.UserID,
		&i.Comment,
		&i.CreatedAt,
	)
	return i, err
}

const addIngredient = `-- name: AddIngredient :one
INSERT INTO ingredients (name)
VALUES ($1)
ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
RETURNING id, name
`

func (q *Queries) AddIngredient(ctx context.Context, name string) (Ingredient, error) {
	row := q.db.QueryRow(ctx, addIngredient, name)
	var i Ingredient
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const addRecipeIngredient = `-- name: AddRecipeIngredient :one
INSERT INTO recipe_ingredients (
  recipe_id, ingredient_id, quantity
) VALUES (
  $1, $2, $3
)
RETURNING id, recipe_id, ingredient_id, quantity
`

type AddRecipeIngredientParams struct {
	RecipeID     pgtype.Int4
	IngredientID pgtype.Int4
	Quantity     pgtype.Text
}

func (q *Queries) AddRecipeIngredient(ctx context.Context, arg AddRecipeIngredientParams) (RecipeIngredient, error) {
	row := q.db.QueryRow(ctx, addRecipeIngredient, arg.RecipeID, arg.IngredientID, arg.Quantity)
	var i RecipeIngredient
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.IngredientID,
		&i.Quantity,
	)
	return i, err
}

const addRecipeStep = `-- name: AddRecipeStep :one
INSERT INTO recipe_steps (
  recipe_id, step_number, description, media_url
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, recipe_id, step_number, description, media_url
`

type AddRecipeStepParams struct {
	RecipeID    pgtype.Int4
	StepNumber  int32
	Description string
	MediaUrl    pgtype.Text
}

func (q *Queries) AddRecipeStep(ctx context.Context, arg AddRecipeStepParams) (RecipeStep, error) {
	row := q.db.QueryRow(ctx, addRecipeStep,
		arg.RecipeID,
		arg.StepNumber,
		arg.Description,
		arg.MediaUrl,
	)
	var i RecipeStep
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.StepNumber,
		&i.Description,
		&i.MediaUrl,
	)
	return i, err
}

const addTag = `-- name: AddTag :one
INSERT INTO tags (name)
VALUES ($1)
ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
RETURNING id, name
`

func (q *Queries) AddTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, addTag, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (
  user_id, title, description, instructions, image_url,
  prep_time_minutes, brew_time_minutes, servings, is_public
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, user_id, title, description, instructions, image_url, prep_time_minutes, brew_time_minutes, servings, is_public, created_at, updated_at
`

type CreateRecipeParams struct {
	UserID          pgtype.Int4
	Title           string
	Description     string
	Instructions    string
	ImageUrl        string
	PrepTimeMinutes pgtype.Int4
	BrewTimeMinutes pgtype.Int4
	Servings        pgtype.Int4
	IsPublic        pgtype.Bool
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Instructions,
		arg.ImageUrl,
		arg.PrepTimeMinutes,
		arg.BrewTimeMinutes,
		arg.Servings,
		arg.IsPublic,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Instructions,
		&i.ImageUrl,
		&i.PrepTimeMinutes,
		&i.BrewTimeMinutes,
		&i.Servings,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  username, email, password_hash, bio, avatar_url
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, username, email, password_hash, bio, avatar_url, created_at
`

type CreateUserParams struct {
	Username     string
	Email        string
	PasswordHash string
	Bio          string
	AvatarUrl    string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.Bio,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.Bio,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM recipe_comments
WHERE id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteComment, id)
	return err
}

const deleteRecipe = `-- name: DeleteRecipe :exec
DELETE FROM recipes
WHERE id = $1
`

func (q *Queries) DeleteRecipe(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRecipe, id)
	return err
}

const favoriteRecipe = `-- name: FavoriteRecipe :exec
INSERT INTO favorites (user_id, recipe_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type FavoriteRecipeParams struct {
	UserID   int32
	RecipeID int32
}

func (q *Queries) FavoriteRecipe(ctx context.Context, arg FavoriteRecipeParams) error {
	_, err := q.db.Exec(ctx, favoriteRecipe, arg.UserID, arg.RecipeID)
	return err
}

const getRecipe = `-- name: GetRecipe :one
SELECT id, user_id, title, description, instructions, image_url, prep_time_minutes, brew_time_minutes, servings, is_public, created_at, updated_at FROM recipes
WHERE id = $1 AND is_public = true
`

func (q *Queries) GetRecipe(ctx context.Context, id int32) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipe, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Instructions,
		&i.ImageUrl,
		&i.PrepTimeMinutes,
		&i.BrewTimeMinutes,
		&i.Servings,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, username, email, password_hash, bio, avatar_url, created_at FROM users
WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.Bio,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash, bio, avatar_url, created_at FROM users
WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.Bio,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const isRecipeFavorited = `-- name: IsRecipeFavorited :one
SELECT EXISTS (
  SELECT 1 FROM favorites
  WHERE user_id = $1 AND recipe_id = $2
) AS favorited
`

type IsRecipeFavoritedParams struct {
	UserID   int32
	RecipeID int32
}

func (q *Queries) IsRecipeFavorited(ctx context.Context, arg IsRecipeFavoritedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isRecipeFavorited, arg.UserID, arg.RecipeID)
	var favorited bool
	err := row.Scan(&favorited)
	return favorited, err
}

const listComments = `-- name: ListComments :many
SELECT rc.comment, rc.created_at, u.username, u.avatar_url
FROM recipe_comments rc
JOIN users u ON rc.user_id = u.id
WHERE rc.recipe_id = $1
ORDER BY rc.created_at DESC
`

type ListCommentsRow struct {
	Comment   string
	CreatedAt pgtype.Timestamp
	Username  string
	AvatarUrl string
}

func (q *Queries) ListComments(ctx context.Context, recipeID pgtype.Int4) ([]ListCommentsRow, error) {
	rows, err := q.db.Query(ctx, listComments, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCommentsRow
	for rows.Next() {
		var i ListCommentsRow
		if err := rows.Scan(
			&i.Comment,
			&i.CreatedAt,
			&i.Username,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentsByUser = `-- name: ListCommentsByUser :many
SELECT id, recipe_id, user_id, comment, created_at FROM recipe_comments
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCommentsByUser(ctx context.Context, userID pgtype.Int4) ([]RecipeComment, error) {
	rows, err := q.db.Query(ctx, listCommentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeComment
	for rows.Next() {
		var i RecipeComment
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.UserID,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicRecipes = `-- name: ListPublicRecipes :many
SELECT id, user_id, title, description, instructions, image_url, prep_time_minutes, brew_time_minutes, servings, is_public, created_at, updated_at FROM recipes
WHERE is_public = true
ORDER BY created_at DESC
`

func (q *Queries) ListPublicRecipes(ctx context.Context) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listPublicRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Instructions,
			&i.ImageUrl,
			&i.PrepTimeMinutes,
			&i.BrewTimeMinutes,
			&i.Servings,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipeIngredients = `-- name: ListRecipeIngredients :many
SELECT ri.quantity, i.name
FROM recipe_ingredients ri
JOIN ingredients i ON ri.ingredient_id = i.id
WHERE ri.recipe_id = $1
`

type ListRecipeIngredientsRow struct {
	Quantity pgtype.Text
	Name     string
}

func (q *Queries) ListRecipeIngredients(ctx context.Context, recipeID pgtype.Int4) ([]ListRecipeIngredientsRow, error) {
	rows, err := q.db.Query(ctx, listRecipeIngredients, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecipeIngredientsRow
	for rows.Next() {
		var i ListRecipeIngredientsRow
		if err := rows.Scan(&i.Quantity, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipeSteps = `-- name: ListRecipeSteps :many
SELECT id, recipe_id, step_number, description, media_url FROM recipe_steps
WHERE recipe_id = $1
ORDER BY step_number
`

func (q *Queries) ListRecipeSteps(ctx context.Context, recipeID pgtype.Int4) ([]RecipeStep, error) {
	rows, err := q.db.Query(ctx, listRecipeSteps, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeStep
	for rows.Next() {
		var i RecipeStep
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.StepNumber,
			&i.Description,
			&i.MediaUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipeTags = `-- name: ListRecipeTags :many
SELECT t.name
FROM recipe_tags rt
JOIN tags t ON rt.tag_id = t.id
WHERE rt.recipe_id = $1
`

func (q *Queries) ListRecipeTags(ctx context.Context, recipeID int32) ([]string, error) {
	rows, err := q.db.Query(ctx, listRecipeTags, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserFavorites = `-- name: ListUserFavorites :many
SELECT r.id, r.user_id, r.title, r.description, r.instructions, r.image_url, r.prep_time_minutes, r.brew_time_minutes, r.servings, r.is_public, r.created_at, r.updated_at
FROM favorites f
JOIN recipes r ON f.recipe_id = r.id
WHERE f.user_id = $1
ORDER BY f.created_at DESC
`

func (q *Queries) ListUserFavorites(ctx context.Context, userID int32) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listUserFavorites, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Instructions,
			&i.ImageUrl,
			&i.PrepTimeMinutes,
			&i.BrewTimeMinutes,
			&i.Servings,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRecipes = `-- name: ListUserRecipes :many
SELECT id, user_id, title, description, instructions, image_url, prep_time_minutes, brew_time_minutes, servings, is_public, created_at, updated_at FROM recipes
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUserRecipes(ctx context.Context, userID pgtype.Int4) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listUserRecipes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Instructions,
			&i.ImageUrl,
			&i.PrepTimeMinutes,
			&i.BrewTimeMinutes,
			&i.Servings,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagRecipe = `-- name: TagRecipe :exec
INSERT INTO recipe_tags (recipe_id, tag_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type TagRecipeParams struct {
	RecipeID int32
	TagID    int32
}

func (q *Queries) TagRecipe(ctx context.Context, arg TagRecipeParams) error {
	_, err := q.db.Exec(ctx, tagRecipe, arg.RecipeID, arg.TagID)
	return err
}

const unfavoriteRecipe = `-- name: UnfavoriteRecipe :exec
DELETE FROM favorites
WHERE user_id = $1 AND recipe_id = $2
`

type UnfavoriteRecipeParams struct {
	UserID   int32
	RecipeID int32
}

func (q *Queries) UnfavoriteRecipe(ctx context.Context, arg UnfavoriteRecipeParams) error {
	_, err := q.db.Exec(ctx, unfavoriteRecipe, arg.UserID, arg.RecipeID)
	return err
}

const updateComment = `-- name: UpdateComment :exec
UPDATE recipe_comments
SET comment = $2
WHERE id = $1
`

type UpdateCommentParams struct {
	ID      int32
	Comment string
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.Exec(ctx, updateComment, arg.ID, arg.Comment)
	return err
}

const updateRecipe = `-- name: UpdateRecipe :exec
UPDATE recipes SET
  title = $2,
  description = $3,
  instructions = $4,
  image_url = $5,
  prep_time_minutes = $6,
  brew_time_minutes = $7,
  servings = $8,
  is_public = $9,
  updated_at = NOW()
WHERE id = $1
`

type UpdateRecipeParams struct {
	ID              int32
	Title           string
	Description     string
	Instructions    string
	ImageUrl        string
	PrepTimeMinutes pgtype.Int4
	BrewTimeMinutes pgtype.Int4
	Servings        pgtype.Int4
	IsPublic        pgtype.Bool
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) error {
	_, err := q.db.Exec(ctx, updateRecipe,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Instructions,
		arg.ImageUrl,
		arg.PrepTimeMinutes,
		arg.BrewTimeMinutes,
		arg.Servings,
		arg.IsPublic,
	)
	return err
}
