// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addComment = `-- name: AddComment :one
INSERT INTO recipe_comments (
  recipe_id, user_id, comment
) VALUES (
  $1, $2, $3
)
RETURNING id, recipe_id, user_id, comment, created_at
`

type AddCommentParams struct {
	RecipeID pgtype.Int4 `json:"recipeId"`
	UserID   pgtype.Int4 `json:"userId"`
	Comment  string      `json:"comment"`
}

func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) (RecipeComment, error) {
	row := q.db.QueryRow(ctx, addComment, arg.RecipeID, arg.UserID, arg.Comment)
	var i RecipeComment
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.UserID,
		&i.Comment,
		&i.CreatedAt,
	)
	return i, err
}

const addRecipeStep = `-- name: AddRecipeStep :one
INSERT INTO recipe_steps (
  recipe_id, step_number, description, asset_id
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, recipe_id, step_number, description, asset_id
`

type AddRecipeStepParams struct {
	RecipeID    pgtype.Int4 `json:"recipeId"`
	StepNumber  int32       `json:"stepNumber"`
	Description string      `json:"description"`
	AssetID     pgtype.Text `json:"assetId"`
}

func (q *Queries) AddRecipeStep(ctx context.Context, arg AddRecipeStepParams) (RecipeStep, error) {
	row := q.db.QueryRow(ctx, addRecipeStep,
		arg.RecipeID,
		arg.StepNumber,
		arg.Description,
		arg.AssetID,
	)
	var i RecipeStep
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.StepNumber,
		&i.Description,
		&i.AssetID,
	)
	return i, err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (
  user_id, title, description, type, asset_id,
  prep_time_minutes, servings, is_public
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, user_id, title, description, type, asset_id, prep_time_minutes, servings, is_public, created_at, updated_at
`

type CreateRecipeParams struct {
	UserID          pgtype.Int4 `json:"userId"`
	Title           string      `json:"title"`
	Description     string      `json:"description"`
	Type            int32       `json:"type"`
	AssetID         string      `json:"assetId"`
	PrepTimeMinutes pgtype.Int4 `json:"prepTimeMinutes"`
	Servings        pgtype.Int4 `json:"servings"`
	IsPublic        pgtype.Bool `json:"isPublic"`
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.AssetID,
		arg.PrepTimeMinutes,
		arg.Servings,
		arg.IsPublic,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.AssetID,
		&i.PrepTimeMinutes,
		&i.Servings,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  email, password_hash, bio, avatar_url
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, email, password_hash, bio, avatar_url, created_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"passwordHash"`
	Bio          string `json:"bio"`
	AvatarUrl    string `json:"avatarUrl"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.Bio,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Bio,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM recipe_comments
WHERE id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteComment, id)
	return err
}

const deleteRecipe = `-- name: DeleteRecipe :exec
DELETE FROM recipes
WHERE id = $1
`

func (q *Queries) DeleteRecipe(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRecipe, id)
	return err
}

const deleteRecipeStep = `-- name: DeleteRecipeStep :exec
DELETE FROM recipe_steps
WHERE id = $1
`

func (q *Queries) DeleteRecipeStep(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRecipeStep, id)
	return err
}

const favoriteRecipe = `-- name: FavoriteRecipe :exec
INSERT INTO favorites (user_id, recipe_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type FavoriteRecipeParams struct {
	UserID   int32 `json:"userId"`
	RecipeID int32 `json:"recipeId"`
}

func (q *Queries) FavoriteRecipe(ctx context.Context, arg FavoriteRecipeParams) error {
	_, err := q.db.Exec(ctx, favoriteRecipe, arg.UserID, arg.RecipeID)
	return err
}

const getRecipe = `-- name: GetRecipe :one
SELECT id, user_id, title, description, type, asset_id, prep_time_minutes, servings, is_public, created_at, updated_at FROM recipes
WHERE id = $1
`

func (q *Queries) GetRecipe(ctx context.Context, id int32) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipe, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.AssetID,
		&i.PrepTimeMinutes,
		&i.Servings,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecipeStep = `-- name: GetRecipeStep :one
SELECT id, recipe_id, step_number, description, asset_id FROM recipe_steps
WHERE id = $1
`

func (q *Queries) GetRecipeStep(ctx context.Context, id int32) (RecipeStep, error) {
	row := q.db.QueryRow(ctx, getRecipeStep, id)
	var i RecipeStep
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.StepNumber,
		&i.Description,
		&i.AssetID,
	)
	return i, err
}

const getRecipeStepByNumber = `-- name: GetRecipeStepByNumber :one
SELECT id, recipe_id, step_number, description, asset_id FROM recipe_steps
WHERE recipe_id = $1 AND step_number = $2
`

type GetRecipeStepByNumberParams struct {
	RecipeID   pgtype.Int4 `json:"recipeId"`
	StepNumber int32       `json:"stepNumber"`
}

func (q *Queries) GetRecipeStepByNumber(ctx context.Context, arg GetRecipeStepByNumberParams) (RecipeStep, error) {
	row := q.db.QueryRow(ctx, getRecipeStepByNumber, arg.RecipeID, arg.StepNumber)
	var i RecipeStep
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.StepNumber,
		&i.Description,
		&i.AssetID,
	)
	return i, err
}

const getRecipeStepsByRecipe = `-- name: GetRecipeStepsByRecipe :many
SELECT id, recipe_id, step_number, description, asset_id FROM recipe_steps
WHERE recipe_id = $1
ORDER BY step_number
`

func (q *Queries) GetRecipeStepsByRecipe(ctx context.Context, recipeID pgtype.Int4) ([]RecipeStep, error) {
	rows, err := q.db.Query(ctx, getRecipeStepsByRecipe, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeStep
	for rows.Next() {
		var i RecipeStep
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.StepNumber,
			&i.Description,
			&i.AssetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, email, password_hash, bio, avatar_url, created_at FROM users
WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Bio,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, bio, avatar_url, created_at FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Bio,
		&i.AvatarUrl,
		&i.CreatedAt,
	)
	return i, err
}

const isRecipeFavorited = `-- name: IsRecipeFavorited :one
SELECT EXISTS (
  SELECT 1 FROM favorites
  WHERE user_id = $1 AND recipe_id = $2
) AS favorited
`

type IsRecipeFavoritedParams struct {
	UserID   int32 `json:"userId"`
	RecipeID int32 `json:"recipeId"`
}

func (q *Queries) IsRecipeFavorited(ctx context.Context, arg IsRecipeFavoritedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isRecipeFavorited, arg.UserID, arg.RecipeID)
	var favorited bool
	err := row.Scan(&favorited)
	return favorited, err
}

const listComments = `-- name: ListComments :many
SELECT rc.comment, rc.created_at, u.email, u.avatar_url
FROM recipe_comments rc
JOIN users u ON rc.user_id = u.id
WHERE rc.recipe_id = $1
ORDER BY rc.created_at DESC
`

type ListCommentsRow struct {
	Comment   string           `json:"comment"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	Email     string           `json:"email"`
	AvatarUrl string           `json:"avatarUrl"`
}

func (q *Queries) ListComments(ctx context.Context, recipeID pgtype.Int4) ([]ListCommentsRow, error) {
	rows, err := q.db.Query(ctx, listComments, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCommentsRow
	for rows.Next() {
		var i ListCommentsRow
		if err := rows.Scan(
			&i.Comment,
			&i.CreatedAt,
			&i.Email,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentsByUser = `-- name: ListCommentsByUser :many
SELECT id, recipe_id, user_id, comment, created_at FROM recipe_comments
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListCommentsByUser(ctx context.Context, userID pgtype.Int4) ([]RecipeComment, error) {
	rows, err := q.db.Query(ctx, listCommentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeComment
	for rows.Next() {
		var i RecipeComment
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.UserID,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicRecipes = `-- name: ListPublicRecipes :many
SELECT id, user_id, title, description, type, asset_id, prep_time_minutes, servings, is_public, created_at, updated_at FROM recipes
WHERE is_public = true
ORDER BY created_at DESC
`

func (q *Queries) ListPublicRecipes(ctx context.Context) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listPublicRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.AssetID,
			&i.PrepTimeMinutes,
			&i.Servings,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicRecipesPaginated = `-- name: ListPublicRecipesPaginated :many
SELECT id, user_id, title, description, type, asset_id, prep_time_minutes, servings, is_public, created_at, updated_at FROM recipes
WHERE is_public = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPublicRecipesPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPublicRecipesPaginated(ctx context.Context, arg ListPublicRecipesPaginatedParams) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listPublicRecipesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.AssetID,
			&i.PrepTimeMinutes,
			&i.Servings,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipeSteps = `-- name: ListRecipeSteps :many
SELECT id, recipe_id, step_number, description, asset_id FROM recipe_steps
WHERE recipe_id = $1
ORDER BY step_number
`

func (q *Queries) ListRecipeSteps(ctx context.Context, recipeID pgtype.Int4) ([]RecipeStep, error) {
	rows, err := q.db.Query(ctx, listRecipeSteps, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeStep
	for rows.Next() {
		var i RecipeStep
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.StepNumber,
			&i.Description,
			&i.AssetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserFavorites = `-- name: ListUserFavorites :many
SELECT r.id, r.user_id, r.title, r.description, r.type, r.asset_id, r.prep_time_minutes, r.servings, r.is_public, r.created_at, r.updated_at
FROM favorites f
JOIN recipes r ON f.recipe_id = r.id
WHERE f.user_id = $1
ORDER BY f.created_at DESC
`

func (q *Queries) ListUserFavorites(ctx context.Context, userID int32) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listUserFavorites, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.AssetID,
			&i.PrepTimeMinutes,
			&i.Servings,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRecipes = `-- name: ListUserRecipes :many
SELECT id, user_id, title, description, type, asset_id, prep_time_minutes, servings, is_public, created_at, updated_at FROM recipes
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUserRecipes(ctx context.Context, userID pgtype.Int4) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, listUserRecipes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.AssetID,
			&i.PrepTimeMinutes,
			&i.Servings,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unfavoriteRecipe = `-- name: UnfavoriteRecipe :exec
DELETE FROM favorites
WHERE user_id = $1 AND recipe_id = $2
`

type UnfavoriteRecipeParams struct {
	UserID   int32 `json:"userId"`
	RecipeID int32 `json:"recipeId"`
}

func (q *Queries) UnfavoriteRecipe(ctx context.Context, arg UnfavoriteRecipeParams) error {
	_, err := q.db.Exec(ctx, unfavoriteRecipe, arg.UserID, arg.RecipeID)
	return err
}

const updateComment = `-- name: UpdateComment :exec
UPDATE recipe_comments
SET comment = $2
WHERE id = $1
`

type UpdateCommentParams struct {
	ID      int32  `json:"id"`
	Comment string `json:"comment"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.Exec(ctx, updateComment, arg.ID, arg.Comment)
	return err
}

const updateRecipe = `-- name: UpdateRecipe :exec
UPDATE recipes SET
  title = $2,
  description = $3,
  type = $4,
  asset_id = $5,
  prep_time_minutes = $6,
  servings = $7,
  is_public = $8,
  updated_at = NOW()
WHERE id = $1
`

type UpdateRecipeParams struct {
	ID              int32       `json:"id"`
	Title           string      `json:"title"`
	Description     string      `json:"description"`
	Type            int32       `json:"type"`
	AssetID         string      `json:"assetId"`
	PrepTimeMinutes pgtype.Int4 `json:"prepTimeMinutes"`
	Servings        pgtype.Int4 `json:"servings"`
	IsPublic        pgtype.Bool `json:"isPublic"`
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) error {
	_, err := q.db.Exec(ctx, updateRecipe,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.AssetID,
		arg.PrepTimeMinutes,
		arg.Servings,
		arg.IsPublic,
	)
	return err
}

const updateRecipeStep = `-- name: UpdateRecipeStep :exec
UPDATE recipe_steps
SET
  step_number = $2,
  description = $3,
  asset_id = $4
WHERE id = $1
`

type UpdateRecipeStepParams struct {
	ID          int32       `json:"id"`
	StepNumber  int32       `json:"stepNumber"`
	Description string      `json:"description"`
	AssetID     pgtype.Text `json:"assetId"`
}

func (q *Queries) UpdateRecipeStep(ctx context.Context, arg UpdateRecipeStepParams) error {
	_, err := q.db.Exec(ctx, updateRecipeStep,
		arg.ID,
		arg.StepNumber,
		arg.Description,
		arg.AssetID,
	)
	return err
}
